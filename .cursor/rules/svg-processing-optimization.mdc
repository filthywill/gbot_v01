---
description: 
globs: */utils/*svg*,**/GraffitiDisplay/*
alwaysApply: false
---
# SVG Processing and Optimization Patterns

## SVG Processing Pipeline

### SVG Validation and Sanitization
```typescript
interface SvgValidationResult {
  isValid: boolean;
  sanitizedSvg?: string;
  error?: string;
  metadata?: SvgMetadata;
}

interface SvgMetadata {
  width: number;
  height: number;
  viewBox: string;
  hasAnimations: boolean;
  elementCount: number;
}

export const validateAndSanitizeSvg = (svgContent: string): SvgValidationResult => {
  try {
    // Basic validation
    if (!svgContent || typeof svgContent !== 'string') {
      return { isValid: false, error: 'Invalid SVG content' };
    }

    // Check for SVG tag
    if (!svgContent.includes('<svg')) {
      return { isValid: false, error: 'No SVG tag found' };
    }

    // Parse SVG to extract metadata
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgContent, 'image/svg+xml');
    const svgElement = doc.querySelector('svg');

    if (!svgElement) {
      return { isValid: false, error: 'Invalid SVG structure' };
    }

    // Extract metadata
    const metadata: SvgMetadata = {
      width: parseFloat(svgElement.getAttribute('width') || '0'),
      height: parseFloat(svgElement.getAttribute('height') || '0'),
      viewBox: svgElement.getAttribute('viewBox') || '',
      hasAnimations: svgContent.includes('<animate') || svgContent.includes('<animateTransform'),
      elementCount: doc.querySelectorAll('*').length,
    };

    // Sanitize SVG (remove scripts, external references)
    const sanitizedSvg = sanitizeSvgContent(svgContent);

    return {
      isValid: true,
      sanitizedSvg,
      metadata,
    };
  } catch (error) {
    return {
      isValid: false,
      error: error instanceof Error ? error.message : 'SVG validation failed',
    };
  }
};

const sanitizeSvgContent = (svgContent: string): string => {
  // Remove script tags
  let sanitized = svgContent.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  
  // Remove external references
  sanitized = sanitized.replace(/href\s*=\s*["'][^"']*["']/gi, '');
  sanitized = sanitized.replace(/xlink:href\s*=\s*["'][^"']*["']/gi, '');
  
  // Remove event handlers
  sanitized = sanitized.replace(/on\w+\s*=\s*["'][^"']*["']/gi, '');
  
  return sanitized;
};
```

### SVG Optimization with SVGO
```typescript
import { optimize } from 'svgo';

interface OptimizationOptions {
  level: 'basic' | 'aggressive' | 'custom';
  preserveViewBox?: boolean;
  removeComments?: boolean;
  removeMetadata?: boolean;
  minifyStyles?: boolean;
}

export const optimizeSvg = async (
  svgContent: string,
  options: OptimizationOptions = { level: 'basic' }
): Promise<{ optimizedSvg: string; originalSize: number; optimizedSize: number; compressionRatio: number }> => {
  const originalSize = new Blob([svgContent]).size;

  try {
    const svgoConfig = getSvgoConfig(options);
    const result = optimize(svgContent, svgoConfig);

    if (result.error) {
      throw new Error(result.error);
    }

    const optimizedSvg = result.data;
    const optimizedSize = new Blob([optimizedSvg]).size;
    const compressionRatio = ((originalSize - optimizedSize) / originalSize) * 100;

    return {
      optimizedSvg,
      originalSize,
      optimizedSize,
      compressionRatio,
    };
  } catch (error) {
    // Return original if optimization fails
    return {
      optimizedSvg: svgContent,
      originalSize,
      optimizedSize: originalSize,
      compressionRatio: 0,
    };
  }
};

const getSvgoConfig = (options: OptimizationOptions) => {
  const baseConfig = {
    plugins: [
      'preset-default',
      {
        name: 'removeViewBox',
        active: !options.preserveViewBox,
      },
    ],
  };

  switch (options.level) {
    case 'aggressive':
      return {
        ...baseConfig,
        plugins: [
          ...baseConfig.plugins,
          'removeDimensions',
          'removeStyleElement',
          'removeScriptElement',
          'removeComments',
          'removeMetadata',
          'removeEditorsNSData',
          'cleanupAttrs',
          'mergeStyles',
          'inlineStyles',
          'minifyStyles',
          'cleanupNumericValues',
          'convertColors',
          'removeUselessStrokeAndFill',
        ],
      };

    case 'custom':
      return {
        ...baseConfig,
        plugins: [
          ...baseConfig.plugins,
          ...(options.removeComments ? ['removeComments'] : []),
          ...(options.removeMetadata ? ['removeMetadata'] : []),
          ...(options.minifyStyles ? ['minifyStyles'] : []),
        ],
      };

    default: // basic
      return baseConfig;
  }
};
```

## Multi-Level Caching Strategy

### SVG Cache Implementation
```typescript
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  accessCount: number;
  lastAccessed: number;
}

interface CacheStats {
  hits: number;
  misses: number;
  size: number;
  hitRate: number;
}

class SvgCache<T> {
  private cache = new Map<string, CacheEntry<T>>();
  private maxSize: number;
  private ttl: number; // Time to live in milliseconds
  private stats: CacheStats = { hits: 0, misses: 0, size: 0, hitRate: 0 };

  constructor(maxSize = 100, ttl = 5 * 60 * 1000) { // 5 minutes default TTL
    this.maxSize = maxSize;
    this.ttl = ttl;
  }

  get(key: string): T | undefined {
    const entry = this.cache.get(key);
    
    if (!entry) {
      this.stats.misses++;
      this.updateHitRate();
      return undefined;
    }

    // Check if entry has expired
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(key);
      this.stats.misses++;
      this.updateHitRate();
      return undefined;
    }

    // Update access statistics
    entry.accessCount++;
    entry.lastAccessed = Date.now();
    this.stats.hits++;
    this.updateHitRate();

    return entry.data;
  }

  set(key: string, data: T): void {
    // Remove oldest entries if cache is full
    if (this.cache.size >= this.maxSize) {
      this.evictLeastRecentlyUsed();
    }

    const entry: CacheEntry<T> = {
      data,
      timestamp: Date.now(),
      accessCount: 1,
      lastAccessed: Date.now(),
    };

    this.cache.set(key, entry);
    this.stats.size = this.cache.size;
  }

  private evictLeastRecentlyUsed(): void {
    let oldestKey = '';
    let oldestTime = Date.now();

    for (const [key, entry] of this.cache.entries()) {
      if (entry.lastAccessed < oldestTime) {
        oldestTime = entry.lastAccessed;
        oldestKey = key;
      }
    }

    if (oldestKey) {
      this.cache.delete(oldestKey);
    }
  }

  private updateHitRate(): void {
    const total = this.stats.hits + this.stats.misses;
    this.stats.hitRate = total > 0 ? (this.stats.hits / total) * 100 : 0;
  }

  clear(): void {
    this.cache.clear();
    this.stats = { hits: 0, misses: 0, size: 0, hitRate: 0 };
  }

  getStats(): CacheStats {
    return { ...this.stats };
  }

  // Cleanup expired entries
  cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now - entry.timestamp > this.ttl) {
        this.cache.delete(key);
      }
    }
    this.stats.size = this.cache.size;
  }
}

// Global cache instances
export const rawSvgCache = new SvgCache<string>(50, 10 * 60 * 1000); // 10 minutes
export const optimizedSvgCache = new SvgCache<string>(100, 30 * 60 * 1000); // 30 minutes
export const processedSvgCache = new SvgCache<ProcessedSvgData>(200, 60 * 60 * 1000); // 1 hour
```

### Cache Key Generation
```typescript
interface CacheKeyParams {
  letterStyle: string;
  letter: string;
  customizations?: CustomizationOptions;
  optimizationLevel?: string;
}

export const generateCacheKey = (params: CacheKeyParams): string => {
  const { letterStyle, letter, customizations, optimizationLevel } = params;
  
  // Create a stable key from parameters
  const keyParts = [
    `style:${letterStyle}`,
    `letter:${letter}`,
  ];

  if (customizations) {
    // Sort customization keys for consistent ordering
    const sortedCustomizations = Object.keys(customizations)
      .sort()
      .map(key => `${key}:${customizations[key as keyof CustomizationOptions]}`)
      .join(',');
    keyParts.push(`custom:${sortedCustomizations}`);
  }

  if (optimizationLevel) {
    keyParts.push(`opt:${optimizationLevel}`);
  }

  return keyParts.join('|');
};

// Hash function for very long keys
export const hashCacheKey = (key: string): string => {
  if (key.length < 100) return key;
  
  // Simple hash function for longer keys
  let hash = 0;
  for (let i = 0; i < key.length; i++) {
    const char = key.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return `hash:${hash.toString(36)}`;
};
```

## Pixel Analysis and Collision Detection

### SVG to Canvas Conversion
```typescript
interface PixelAnalysisResult {
  boundingBox: BoundingBox;
  pixelData: Uint8ClampedArray;
  width: number;
  height: number;
  nonTransparentPixels: number;
}

interface BoundingBox {
  x: number;
  y: number;
  width: number;
  height: number;
}

export const analyzeSvgPixels = async (
  svgContent: string,
  targetWidth = 200,
  targetHeight = 200
): Promise<PixelAnalysisResult> => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    if (!ctx) {
      reject(new Error('Canvas context not available'));
      return;
    }
    
    canvas.width = targetWidth;
    canvas.height = targetHeight;

    const img = new Image();
    
    img.onload = () => {
      try {
        // Clear canvas
        ctx.clearRect(0, 0, targetWidth, targetHeight);
        
        // Draw SVG
        ctx.drawImage(img, 0, 0, targetWidth, targetHeight);
        
        // Get pixel data
        const imageData = ctx.getImageData(0, 0, targetWidth, targetHeight);
        const pixelData = imageData.data;
        
        // Analyze pixels
        const boundingBox = calculateBoundingBox(pixelData, targetWidth, targetHeight);
        const nonTransparentPixels = countNonTransparentPixels(pixelData);
        
        resolve({
          boundingBox,
          pixelData,
          width: targetWidth,
          height: targetHeight,
          nonTransparentPixels,
        });
      } catch (error) {
        reject(error);
      }
    };

    img.onerror = () => {
      reject(new Error('Failed to load SVG image'));
    };

    // Convert SVG to data URL
    const svgBlob = new Blob([svgContent], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(svgBlob);
    img.src = url;
    
    // Cleanup
    img.onload = () => {
      URL.revokeObjectURL(url);
      img.onload();
    };
  });
};

const calculateBoundingBox = (
  pixelData: Uint8ClampedArray,
  width: number,
  height: number
): BoundingBox => {
  let minX = width, minY = height, maxX = 0, maxY = 0;
  
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const alpha = pixelData[(y * width + x) * 4 + 3];
      
      if (alpha > 0) { // Non-transparent pixel
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
    }
  }
  
  return {
    x: minX,
    y: minY,
    width: maxX - minX + 1,
    height: maxY - minY + 1,
  };
};

const countNonTransparentPixels = (pixelData: Uint8ClampedArray): number => {
  let count = 0;
  for (let i = 3; i < pixelData.length; i += 4) {
    if (pixelData[i] > 0) count++;
  }
  return count;
};
```

### Overlap Calculation Optimization
```typescript
interface OverlapResult {
  hasOverlap: boolean;
  overlapArea: number;
  overlapPercentage: number;
  suggestedSpacing: number;
}

export const calculateOptimalOverlap = (
  leftLetter: PixelAnalysisResult,
  rightLetter: PixelAnalysisResult,
  maxOverlapPercentage = 15
): OverlapResult => {
  const leftBounds = leftLetter.boundingBox;
  const rightBounds = rightLetter.boundingBox;
  
  // Start with letters touching
  let spacing = 0;
  let bestSpacing = 0;
  let minOverlap = Infinity;
  
  // Test different spacing values
  for (let testSpacing = -50; testSpacing <= 50; testSpacing += 2) {
    const overlap = calculateOverlapAtSpacing(
      leftLetter,
      rightLetter,
      testSpacing
    );
    
    if (overlap.overlapPercentage <= maxOverlapPercentage && 
        overlap.overlapPercentage < minOverlap) {
      minOverlap = overlap.overlapPercentage;
      bestSpacing = testSpacing;
    }
  }
  
  // Calculate final overlap at best spacing
  const finalOverlap = calculateOverlapAtSpacing(
    leftLetter,
    rightLetter,
    bestSpacing
  );
  
  return {
    ...finalOverlap,
    suggestedSpacing: bestSpacing,
  };
};

const calculateOverlapAtSpacing = (
  leftLetter: PixelAnalysisResult,
  rightLetter: PixelAnalysisResult,
  spacing: number
): OverlapResult => {
  const leftBounds = leftLetter.boundingBox;
  const rightBounds = rightLetter.boundingBox;
  
  // Calculate positions
  const rightStartX = leftBounds.x + leftBounds.width + spacing;
  
  // Check if there's any overlap
  const overlapStartX = Math.max(leftBounds.x, rightStartX);
  const overlapEndX = Math.min(leftBounds.x + leftBounds.width, rightStartX + rightBounds.width);
  
  if (overlapStartX >= overlapEndX) {
    return {
      hasOverlap: false,
      overlapArea: 0,
      overlapPercentage: 0,
      suggestedSpacing: spacing,
    };
  }
  
  // Calculate overlap area using pixel-perfect detection
  const overlapArea = calculatePixelOverlap(
    leftLetter,
    rightLetter,
    spacing
  );
  
  const totalArea = leftLetter.nonTransparentPixels + rightLetter.nonTransparentPixels;
  const overlapPercentage = totalArea > 0 ? (overlapArea / totalArea) * 100 : 0;
  
  return {
    hasOverlap: overlapArea > 0,
    overlapArea,
    overlapPercentage,
    suggestedSpacing: spacing,
  };
};

const calculatePixelOverlap = (
  leftLetter: PixelAnalysisResult,
  rightLetter: PixelAnalysisResult,
  spacing: number
): number => {
  // This is a simplified version - in practice, you'd need to
  // account for the actual pixel positions and alpha values
  const leftBounds = leftLetter.boundingBox;
  const rightBounds = rightLetter.boundingBox;
  
  const rightStartX = leftBounds.x + leftBounds.width + spacing;
  const overlapWidth = Math.max(0, 
    Math.min(leftBounds.x + leftBounds.width, rightStartX + rightBounds.width) - 
    Math.max(leftBounds.x, rightStartX)
  );
  
  const overlapHeight = Math.max(0,
    Math.min(leftBounds.y + leftBounds.height, rightBounds.y + rightBounds.height) -
    Math.max(leftBounds.y, rightBounds.y)
  );
  
  return overlapWidth * overlapHeight;
};
```

## Performance Monitoring and Metrics

### Performance Tracker
```typescript
interface PerformanceMetrics {
  operation: string;
  duration: number;
  timestamp: number;
  cacheHit?: boolean;
  inputSize?: number;
  outputSize?: number;
}

class SvgPerformanceTracker {
  private metrics: PerformanceMetrics[] = [];
  private maxMetrics = 1000;

  startOperation(operation: string): () => PerformanceMetrics {
    const startTime = performance.now();
    
    return (additionalData?: Partial<PerformanceMetrics>) => {
      const duration = performance.now() - startTime;
      const metric: PerformanceMetrics = {
        operation,
        duration,
        timestamp: Date.now(),
        ...additionalData,
      };
      
      this.addMetric(metric);
      return metric;
    };
  }

  private addMetric(metric: PerformanceMetrics): void {
    this.metrics.push(metric);
    
    // Keep only recent metrics
    if (this.metrics.length > this.maxMetrics) {
      this.metrics.shift();
    }
  }

  getMetrics(operation?: string): PerformanceMetrics[] {
    if (operation) {
      return this.metrics.filter(m => m.operation === operation);
    }
    return [...this.metrics];
  }

  getAverageTime(operation: string): number {
    const operationMetrics = this.getMetrics(operation);
    if (operationMetrics.length === 0) return 0;
    
    const total = operationMetrics.reduce((sum, m) => sum + m.duration, 0);
    return total / operationMetrics.length;
  }

  getCacheHitRate(operation: string): number {
    const operationMetrics = this.getMetrics(operation);
    const cacheHits = operationMetrics.filter(m => m.cacheHit === true).length;
    
    return operationMetrics.length > 0 ? (cacheHits / operationMetrics.length) * 100 : 0;
  }

  getCompressionStats(): { averageRatio: number; totalSaved: number } {
    const compressionMetrics = this.metrics.filter(m => 
      m.inputSize && m.outputSize && m.inputSize > m.outputSize
    );
    
    if (compressionMetrics.length === 0) {
      return { averageRatio: 0, totalSaved: 0 };
    }
    
    const totalInput = compressionMetrics.reduce((sum, m) => sum + (m.inputSize || 0), 0);
    const totalOutput = compressionMetrics.reduce((sum, m) => sum + (m.outputSize || 0), 0);
    const totalSaved = totalInput - totalOutput;
    const averageRatio = totalInput > 0 ? (totalSaved / totalInput) * 100 : 0;
    
    return { averageRatio, totalSaved };
  }

  clear(): void {
    this.metrics = [];
  }
}

export const svgPerformanceTracker = new SvgPerformanceTracker();
```

### Usage Example
```typescript
export const processLetterSvg = async (
  letter: string,
  style: string,
  customizations: CustomizationOptions
): Promise<string> => {
  const endTracking = svgPerformanceTracker.startOperation('processLetterSvg');
  
  try {
    // Generate cache key
    const cacheKey = generateCacheKey({ letter, letterStyle: style, customizations });
    
    // Check cache first
    const cached = processedSvgCache.get(cacheKey);
    if (cached) {
      endTracking({ cacheHit: true });
      return cached.svg;
    }
    
    // Load raw SVG
    const rawSvg = await loadLetterSvg(letter, style);
    const inputSize = new Blob([rawSvg]).size;
    
    // Optimize SVG
    const { optimizedSvg } = await optimizeSvg(rawSvg, { level: 'basic' });
    
    // Apply customizations
    const customizedSvg = applyCustomizations(optimizedSvg, customizations);
    
    // Analyze pixels for positioning
    const pixelAnalysis = await analyzeSvgPixels(customizedSvg);
    
    const outputSize = new Blob([customizedSvg]).size;
    
    // Cache result
    processedSvgCache.set(cacheKey, {
      svg: customizedSvg,
      pixelAnalysis,
      metadata: { inputSize, outputSize },
    });
    
    endTracking({ 
      cacheHit: false, 
      inputSize, 
      outputSize 
    });
    
    return customizedSvg;
  } catch (error) {
    endTracking({ cacheHit: false });
    throw error;
  }
};
```

## Browser Compatibility and Fallbacks

### SVG Support Detection
```typescript
export const detectSvgSupport = (): {
  basicSupg: boolean;
  inlineSupport: boolean;
  animationSupport: boolean;
  filterSupport: boolean;
} => {
  const testSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  
  return {
    basicSupg: !!testSvg.createSVGRect,
    inlineSupport: document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1'),
    animationSupport: typeof SVGAnimateElement !== 'undefined',
    filterSupport: typeof SVGFEColorMatrixElement !== 'undefined',
  };
};

// Safari-specific optimizations
export const isSafari = (): boolean => {
  return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
};

export const applySafariOptimizations = (svgContent: string): string => {
  if (!isSafari()) return svgContent;
  
  // Safari-specific optimizations
  let optimized = svgContent;
  
  // Ensure proper namespace declarations
  if (!optimized.includes('xmlns="http://www.w3.org/2000/svg"')) {
    optimized = optimized.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  
  // Remove problematic filter effects that Safari doesn't handle well
  optimized = optimized.replace(/filter\s*=\s*["'][^"']*["']/gi, '');
  
  return optimized;
};
```

These patterns ensure efficient, performant SVG processing with comprehensive caching, optimization, and browser compatibility for the graffiti generation application.
